;
; DASLIB.ACT
;
; Dave's Action Library
; 
; David Snyder
; January 18, 2022
;
;  SAVE TO H6: FOR TEXT SAVE TO HDD

CARD Addr=[$FC00]
BYTE POINTER LMargn=$52

CARD txtRow=[$290] ; TXTROW
CARD txtCol=[$291] ; TXTCOLL, TXTCOLH

BYTE stick0=632
BYTE strig0=644
BYTE consol=53279
DEFINE START="6"
DEFINE OPTION="3"
DEFINE SELECT="5"
DEFINE PRESSED="0"

CARD ch1prev=754   ; keyboard char key accepted
CARD chread=764    ; 255 = no key
CARD crsinh=[752]  ; $2F0  0=CursorON, else OFF
; x and y max screen positions
; Default to Graphics 2 to be safe
BYTE gXMax=[19]    
BYTE gYMax=[9]     

; After setting Graphics Mode, call this to set extents
PROC SetScreenExtents(BYTE grMode)
  ; default to Gr.2 to be safe
  gXMax = 19   ; Gr. 1/2 both have 0-19 columns
  gYMax = 9    ; Gr. 2 has 9 rows
  IF grMode=1 THEN
    gYMax=19
  ELSEIF grMode=(17) THEN
    gYMax=23
  ELSEIF grMode=(18) THEN
    gYMax=11
  FI
RETURN  ; SetScreenExtents()

Proc MyDelay(CARD dly)
  CARD ix
  BYTE q
  FOR ix=0 TO dly
    DO
    q=1
    OD
RETURN


Proc PrintCCs(INT x,y,t, BYTE c,
     BYTE ARRAY szString)
  BYTE nLen
  BYTE idx, ch, chD
  BYTE mask
  INT  xPos  ; Calculated X Position
  nLen = szString(0); Length of String
  FOR idx=1 to nLen  ; 0=len, start @1
  DO  
    mask=$00  ; default to color 0
    IF (c=1) THEN mask=$20
     ELSEIF (c=2) THEN mask=$80
     ELSEIF (c=3) THEN mask=$A0
    FI

    ch = szString(idx)
    IF ch<$40 THEN ch==-$20
      ELSEIF ch>$7F THEN ch==-$40
      ELSEIF ch>$5F THEN ch==-$20
    FI             
    IF ch>$1F THEN mask=$20  ; color mask is dif
      IF (c=1) THEN mask=$00
       ELSEIF (c=2) THEN mask=$A0
       ELSEIF (c=3) THEN mask=$80
      FI ; endif color adjusted
    FI ; endif ch>$1F (ASCII)

    Color=(ch%mask) ; set character at color
    ; if tilt >=5 or <=-5 then go vertical
    IF (t>=5) THEN y==+1
      ELSEIF (t<=-5) THEN y==-1
      ELSE y==+t    ; allow for tilt!
    FI     
    ; maybe just vertical!
    IF ((t<5) AND (t>-5)) THEN
      xpos = x+(idx-1) ; calc xpos
    ELSE xpos=x  ; if vertical then no change to x
    FI

    ; Make sure I am not offscreen (ERR 141)
    IF (xpos>gXMax) THEN xpos=gXMax FI
    IF (y>gYMax) THEN y=gYMax FI
    IF (xpos<0) THEN x=0 FI
    IF (y<0) THEN y=0 FI
    Plot(xpos,y)

  OD    ; NEXT idx

RETURN  ; end PrintCCs()

;
; Print Single Character at position - no tilt option
;
Proc PrintC1(INT x,y, BYTE c, ch)
  BYTE mask
  INT  xpos  ; Calculated X Position
  
    mask=$00  ; default to color 0
    IF (c=1) THEN mask=$20
     ELSEIF (c=2) THEN mask=$80
     ELSEIF (c=3) THEN mask=$A0
    FI

    IF ch<$40 THEN ch==-$20
      ELSEIF ch>$7F THEN ch==-$40
      ELSEIF ch>$5F THEN ch==-$20
    FI             
    IF ch>$1F THEN mask=$20  ; color mask is dif
      IF (c=1) THEN mask=$00
       ELSEIF (c=2) THEN mask=$A0
       ELSEIF (c=3) THEN mask=$80
      FI ; endif color adjusted
    FI ; endif ch>$1F (ASCII)

    Color=(ch%mask) ; set character at color
    xpos=x  ; x position

    ; Make sure I am not offscreen (ERR 141)
    IF (xpos>gXMax) THEN xpos=gXMax FI
    IF (y>gYMax) THEN y=gYMax FI
    IF (xpos<0) THEN x=0 FI
    IF (y<0) THEN y=0 FI
    Plot(xpos,y)

RETURN  ; end PrintC1()

Proc ClearTW()
    BYTE ARRAY sz="     "
    sz(1)=125  ; 125 is clear screen
    PokeC(txtCol, 0); Column 0-39
    Poke(txtRow,0) ; Row 0-3
    Print(sz)
RETURN

; Clear Text Window Row
; Doesnt clear column 39 - else scrolls
Proc ClearTWRow(BYTE r)
   BYTE ARRAY sz="                                       "
;    BYTE ARRAY sz=".........+.........+.........+........x"
    if (r>3) THEN r=3 FI
    PokeC(txtCol, 0); Column 0-39
    Poke(txtRow,r) ; Row 0-3
    Print(sz)
RETURN


Proc PrintTW(BYTE col, row, BYTE ARRAY txtString)
  ; if txt is out of range, then set to 0,0 to be obvious (and safe)
  BYTE nLen
  nLen = txtString(0)

  IF col > 38 THEN col=0 FI
  IF row > 3 THEN  row=0 FI

  ; Make sure string isnt too long
  IF ((col+nLen)>40) THEN
    col = 0  ; force column to 0
  FI

  IF ((nLen > 0) AND (nLen < 39)) THEN
    Poke(txtRow, row) ; Row 0-3
    PokeC(txtCol, col); Column 0-39
    Print(txtString)  ; Notice no CR here
  FI

RETURN

Proc WaitForBtn()
  DO
  UNTIL (Strig0=PRESSED)
  OD  
RETURN

; end of Library File



